动态链接，在可执行文件装载时或运行时，由操作系统的装载程序加载库。大多数操作系统将解析外部引用（比如库）作为加载过程的一部分。在这些系统上，可执行文件包含一个叫做import directory的表，该表的每一项包含一个库的名字。根据表中记录的名字，装载程序在硬盘上搜索需要的库，然后将其加载到内存中预先不确定的位置，之后根据加载库后确定的库的地址更新可执行程序。可执行程序根据更新后的库信息调用库中的函数或引用库中的数据。这种类型的动态加载成为装载时加载 ，被包括Windows和Linux的大多数系统采用。装载程序在加载应用软件时要完成的最复杂的工作之一就是加载时链接。

其他操作系统可能在运行时解析引用。在这些系统上，可执行程序调用操作系统API，将库的名字，函数在库中的编号和函数参数一同传递。操作系统负责立即解析然后代表应用调用合适的函数。这种动态链接叫做运行时链接 。因为每个调用都会有系统开销，运行时链接要慢得多，对应用的性能有负面影响。现代操作系统已经很少使用运行时链接。

可以动态链接的库，在Windows上是dynamic link library (DLL)，在UNIX或Linux上是Shared Library。库文件是预先编译链接好的可执行文件，存储在计算机的硬盘上。大多数情况下，同一时间多个应用可以使用一个库的同一份拷贝，操作系统不需要加载这个库的多个实例。

Windows 和 Linux 的加载时链接是由操作系统来完成的，格式在不同的系统下有不同的区别，但是原理还是一样的。

linux下文件的类型是不依赖于其后缀名的，但一般来讲：
.o,是目标文件,相当于windows中的.obj文件
.so 为共享库,是shared object,用于动态连接的,和dll差不多
.a为静态库,是好多个.o合在一起,用于静态连接
.la为libtool自动生成的一些共享库，vi编辑查看，主要记录了一些配置信息。可以用如下命令查看*.la文件的格式 $file *.la
*.la: ASCII English text
所以可以用vi来查看其内容。

无论是动态库还是静态库，都得由.o文件创建，所以我们先编译出.o文件。
g++ -c hello.cpp

1.静态库创建及链接
    使用 ar crv 命令创立静态库。
    建立出了静态库文件 libmyhello.a ，静态库文件后缀为.a 。
    ar crv libmyhello.a hello.o 

    使用 g++ 命令链接静态库
    g++ main.cpp libmyhello.a -o main 
    生成了可执行文件main，且可以正常运行。
    删除静态库libmyhello.a，程序仍能运行，说明链接成功。

2.动态库创建及链接
    使用 -shared -fPCI 命令创立动态库。
    g++ one.cpp tow.cpp three.cpp -fPIC -shared -o libtest.so 
    建立出了动态库文件 libtest.so ，动态库文件后缀为.so 。

    使用 g++ 命令链接动态库
    g++ main.cpp -L. -ltest -o main 
    /*
    -L代表so库目录，L.代表当前目录，-I代表引用文件目录，main 即为可执行文件
    */
    生成可执行文件main
    直接运行会报错：缺少文件。我们将动态库移动到/usr/lib 中即可

    随后即可正常运行（如果移动后仍不能运行，请看下文)

3.相关问题
移动动态库后仍不能运行

1.首先进入 /etc/ld.so.conf 文件
vim /etc/ld.so.conf
2.修改内容为如下
include /etc/ld.so.conf.d/*.conf
3.进入目录，创建任意*.conf文件
cd /etc/ld.so.conf.d
vim mylib.conf
4.在其中添加so的路径即可
/usr/lib
5.执行命令使其生效
sudo ldconfig
随后程序即可正常运行

